<?php

namespace Sysgear\Symfony\Bundle\ServiceBundle\Protocol;

use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Sysgear\Symfony\Bundle\ServiceBundle\ProtocolInterface;
use Sysgear\Symfony\Bundle\ServiceBundle\Service;
use Sysgear\Symfony\Bundle\ServiceBundle\ErrorBuilder;
use Zend\Json\Server\Error;
use Zend\Json\Server\Server;
use Zend\Json\Json;

class Jsonrpc implements ProtocolInterface
{
    protected $adapter;
    protected $service;
    protected $enableDebugging = false;

    /**
     * @var ErrorBuilder
     */
    protected $errorBuilder;

    /**
     * Create jsonrpc protocol.
     *
     * @param ErrorBuilder $errorBuilder
     * @param Server $adapter
     */
    public function __construct(ErrorBuilder $errorBuilder, Server $adapter)
    {
        $this->errorBuilder = $errorBuilder;
        $this->adapter = $adapter;

        // Configure adapter.
        $this->adapter->setAutoEmitResponse(false);
        $this->adapter->errorCallback = array($this, 'errorCallback');
    }

    /**
     * (non-PHPdoc)
     * @see Sysgear\Symfony\Bundle\ServiceBundle.ProtocolInterface::enableDebugging()
     */
    public function enableDebugging($flag)
    {
        $this->enableDebugging = (boolean) $flag;
    }

    /**
     * Handle request.
     *
     * @param Request $request
     * @return Response
     */
    public function handle(Request $request)
    {
        $this->adapter->setTarget($request->getPathInfo());

        $response = new Response();
        if ('GET' === $request->getMethod()) {
            $response->setContent($this->adapter->getServiceMap());
        } else {
            $postData = Json::decode($request->getContent(), Json::TYPE_ARRAY);
            if (empty($postData)) {
                throw new \Exception('No POST data received.');
            }

            $notBatch = array_key_exists('jsonrpc', $postData);
            if ($notBatch) {

                $this->adapter->getRequest()->setOptions($postData);
                $this->adapter->handle();
                $response->setContent($this->adapter->getResponse()->toJson());
            } else {

                $req = $this->adapter->getRequest();
                $res = $this->adapter->getResponse();
                $responses = array();
                foreach ($postData as $options) {
                    $req->setOptions($options);
                    $this->adapter->handle();
                    $responses[] = $res->toJson();
                }
                $response->setContent('['.join(',', $responses).']');
            }
        }
        $response->setStatusCode(200);
        $response->headers->set('Content-Type', 'application/json');
        return $response;
    }

    /**
     * Add a service object.
     *
     * @param Service $service
     * @param boolean $default
     * @return Jsonrpc
     */
    public function addService(Service $service, $default = false)
    {
        $namespace = '';
        if (! $default) {
            $class = get_class($service);
            $namespace = strtolower(substr($class, strrpos($class, '\\') + 1, -7));
        }

        $this->adapter->setClass($service, $namespace);
        $this->service = $service;
        return $this;
    }

    /**
     * Indicate fault response
     *
     * @param \Exception
     * @return Response
     */
    public function fault(\Exception $e)
    {
        $error = $this->errorBuilder->fromException($e);
        $message = $error['message'];
        unset($error['message']);

        $err = new Error($message, Error::ERROR_INTERNAL, $error);
        $this->adapter->getResponse()->setError($err);

        $response = new Response();
        $response->setContent($this->adapter->getResponse()->toJson());
        $response->setStatusCode(200);
        $response->headers->set('Content-Type', 'application/json');
        return $response;
    }

    /**
     * Handle errors generated by the 3rd-party RPC-JSON server.
     *
     * @param string $message
     * @param integer $code
     * @param mixed $data
     */
    public function errorCallback($message, $code, $data)
    {
        if ($data instanceof \Exception) {

            $error = $this->errorBuilder->fromException($data);
            $message = $error['message'];
            unset($error['message']);

            if ($this->enableDebugging) {
                $error['file'] = $data->getFile();
                $error['line'] = $data->getLine();
                $error['trace'] = $data->getTrace();
            }
        } else {
            $error = $data;
        }

        $err = new Error($message, $code, $error);
        return $err;
    }
}